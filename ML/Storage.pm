package ML::Storage;

use strict;
use warnings;

use File::Path qw(make_path);
use File::Basename;
use XML::Simple qw(:strict);

=head1 NAME

ML::Storage - Manage persistent data

=head1 SYNOPSIS

    use ML::Storage;

=head1 DESCRIPTION

This package provides an interface for saving/loading set-related and
other information.

The data passed to these methods for storing data should not be subsequently
modified. It is cached and returned the next time the data ie fetched.

=head1 TODO

=cut

#
############################################################################
#

=head2 General Methods

=over 4
#
############################################################################
#       

=item new ($dir)

Create a new object. $dir is the location for persistent storage.
Current directory is assumed if none is specified. This directory will be
created if it does not already exist.

=cut
#
############################################################################
#
sub new
{
        my($class) = shift;
        my($self) =
        {
		'DIR'		=> '.',
		'INVENTORY'	=> undef,
		'SPLITCARDS'	=> undef,
        };      
                
        bless($self, $class);   
	$self->dir(shift) if @_;
        return($self);
}       
#
############################################################################
#       

=item preserve ($path)

If $path already exists, rename it insead of simply removing it.
The file preserved my moving it to a sub-directory.
The name of the sub-directory is generated by pre-pending B<OLD.>
to its basename.
The file being preserved is moved to this sub-directory and
renamed as a timestamp.

Returns true on success, false otherwise.

TODO: 	Consider using a sub-directory instead of same directory as file
	being preserved.

=cut
#
############################################################################
#
sub preserve
{
        my $self = shift;
	my $path = shift;

	return(1) if (! -e $path);
	my($sec, $min, $hour, $mday, $mon, $year) = (localtime())[0..5];
	my $ts = sprintf("%04d%02d%02d-%02d%02d%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);
	my($filename, $dir) = fileparse($path);
	my $pdir = "$dir/OLD.$filename";
	if (! -d $pdir and !mkdir($pdir, 0755))
	{
		print STDERR "ERROR: preserve(): could not create directory: '$pdir' ($!)\n";
		return(undef);
	}
	my $newpath = "$pdir/$ts";
	if (!rename($path, $newpath))
	{
		print STDERR "ERROR: preserve(): could not rename '$path' to: '$newpath' ($!)\n";
		return(undef);
	}
	return(1);
}
#
############################################################################
#       

=item store ($xml, $path)

Save $xml XML in file $path. $path is preserved if it already exists.

Returns B<undef> on failure. Returns $xml on success.

=cut
#
############################################################################
#
sub store
{
        my $self = shift;
	my($xml, $path) = @_;

	$self->preserve($path) or return(undef);
	if (!open(SET, ">$path"))
	{
		print STDERR "ERROR: store(): open: $path ($!)\n";
		return(undef);
	}
	if (!print SET $xml)
	{
		print STDERR "ERROR: store(): write error to: $path ($!)\n";
		close(SET);
		return(undef);
	}
	close(SET);
	return(1);
}
#
############################################################################
#

=back

=head2 Inventory-related methods

=over 4
#
############################################################################
#       

=item inv ($data)

If $data is specified, save the specified inventory.
Otherwise, load the inventory and a reference to its data.

Returns reference to same data structure as originally passed to inv() when
originally saving.

Returns B<undef> on failure.

=cut
#
############################################################################
#
sub inv
{
        my $self = shift;
	my($data) = @_;
	my $base = 'INVENTORY';
	my $path = $self->dir . "/$base.xml";
	my $keyattr = 'id';

	if ($data)
	{
		$self->{$base} = $data;
		return($self->store(XMLout($data,
			'KeyAttr' => $keyattr,
			'Attrindent' => 1,
		), $path));
	}
	$self->{$base} and return($self->{$base});
	my $xml = eval { XMLin($path,
		'ForceArray' => 1,
		# This needs to be a unique key for all card info
		'KeyAttr' => $keyattr,
	) };
	$@ or return($xml);
	print STDERR "ERROR: inv(): XML parsing errors loading $path: $@\n";
	return(undef);
}
#
############################################################################
#

=back

=head2 Set-related methods

=over 4
#
############################################################################
#       

=item set ($code, $data)

If $data is specified, save the set with three-letter abbreviation $code
and return true on success, false otherwise.
Otherwise, load the set and a reference to its data.

Returns reference to same data structure as originally passed to set()
when the data was saved.

Returns B<undef> on failure.

=cut
#
############################################################################
#
sub set
{
        my $self = shift;
	my($code, $data) = @_;
	my $base = "set_$code";
	my $path = $self->dir . "/$base.xml";
	my $keyattr = 'gid';

	if ($data)
	{
		$self->{$base} = $data;
		return($self->store(XMLout($data,
			'KeyAttr' => $keyattr,
			'Attrindent' => 1,
		), $path));
	}
	$self->{$base} and return($self->{$base});
	my $xml = eval { XMLin($path,
		'ForceArray' => 1,
		# This needs to be a unique key for all card info
		'KeyAttr' => $keyattr,
	) };
	$@ or return($xml);
	print STDERR "ERROR: set(): XML parsing errors loading $code: $@\n";
	return(undef);
}
#
############################################################################
#

=back

=head2 Miscellaneous-related methods

=over 4
#
############################################################################
#       

=item splitcards ($data)

If $data is specified, save the split card information referenced by it.
Otherwise, load the split card info and a reference to its data.

Returns B<undef> on failure.

=cut
#
############################################################################
#
sub splitcards
{
        my $self = shift;
	my($data) = @_;
	my $base = "SPLITCARDS";
	my $path = $self->dir . "/$base.xml";
	my $keyattr = 'name';

	if ($data)
	{
		$self->{$base} = $data;
		return($self->store(XMLout($data,
			'KeyAttr' => $keyattr,
			'Attrindent' => 1,
		), $path));
	}
	$self->{$base} and return($self->{$base});
	my $xml = eval { XMLin($path,
		'ForceArray' => 1,
		# This needs to be a unique key for all card info
		'KeyAttr' => $keyattr,
	) };
	$@ or return($xml);
	print STDERR "ERROR: splitcards(): XML parsing errors loading $path: $@\n";
	return(undef);
}
#
############################################################################
#       

=item isSplitCard ($name)

If $name is one half of a split card, return the full name.

Returns B<undef> otherwise.

=cut
#
############################################################################
#
sub isSplitCard
{
        my $self = shift;
	my($name) = @_;
	my $base = "split_names";

	($self->{$base}) and
		return($self->{$base}->{$name});
	my $rawdata = $self->splitcards;
	my %names;
	foreach my $card (keys(%{ $rawdata->{'cards'} }))
	{
		$names{ $rawdata->{'cards'}->{$card}->{'first'} } =
		$names{ $rawdata->{'cards'}->{$card}->{'last'} } = $card;
	}
	$self->{$base} = \%names;
	return($self->isSplitCard($name));
}
#
############################################################################
#

=back

=head2 Configurable Settings

These subroutines can be used to fetch or modify the constant values
set in new().

=over 4
#
############################################################################
#

=item dir ()

Get or set the path to the file used to store cookies.
Create it if it doesn't exist.

=cut
#
############################################################################
#       
sub dir
{       
        my($self) = shift;
                
	$self->{'DIR'} = shift if (@_);
	make_path($self->{'DIR'}) if (! -d $self->{'DIR'});
	return($self->{'DIR'});
}       
#
############################################################################
#

=back

=head1 AUTHOR

Peter Costantinidis

=cut

1;
